using CleanUps.BusinessLogic.Interfaces.PrivateAccess;
using CleanUps.Shared.DTOs;

namespace CleanUps.BusinessLogic.Validators
{
    internal class EventValidator : IValidator<EventDTO>
    {
        public void ValidateForCreate(EventDTO eventDto)
        {
            if (eventDto == null)
            {
                throw new ArgumentNullException(nameof(eventDto), "Event DTO cannot be null.");
            }

            ValidateCommonFields(eventDto);

            // For create, EventId should not be set (it will be generated by the database)
            if (eventDto.EventId != 0)
            {
                throw new ArgumentException("EventId should not be set when creating a new event.", nameof(eventDto.EventId));
            }
        }

        public void ValidateForUpdate(int id, EventDTO eventDto)
        {
            if (eventDto == null)
            {
                throw new ArgumentNullException(nameof(eventDto), "Event DTO cannot be null.");
            }
            if (id != eventDto.EventId)
            {
                throw new ArgumentException("Event ID and Id from URL does not match", "EventId: " + nameof(eventDto.EventId)+ " " + "Id from URL: " + nameof(id));
            }
            if (id <= 0)
            {
                throw new ArgumentException("Event ID must be greater than zero.", nameof(eventDto.EventId));
            }

            if (eventDto.EventId <= 0)
            {
                throw new ArgumentException("Event ID must be greater than zero.", nameof(eventDto.EventId));
            }

            ValidateCommonFields(eventDto);
        }

        public void ValidateId(int id)
        {
            if (id <= 0)
            {
                throw new ArgumentException("Event ID must be greater than zero.", nameof(id));
            }
        }

        private void ValidateCommonFields(EventDTO eventDto)
        {
            if (string.IsNullOrWhiteSpace(eventDto.StreetName))
            {
                throw new ArgumentException("StreetName is required.", nameof(eventDto.StreetName));
            }

            if (string.IsNullOrWhiteSpace(eventDto.City))
            {
                throw new ArgumentException("City is required.", nameof(eventDto.City));
            }

            if (string.IsNullOrWhiteSpace(eventDto.ZipCode))
            {
                throw new ArgumentException("ZipCode is required.", nameof(eventDto.ZipCode));
            }

            if (string.IsNullOrWhiteSpace(eventDto.Country))
            {
                throw new ArgumentException("Country is required.", nameof(eventDto.Country));
            }

            if (string.IsNullOrWhiteSpace(eventDto.Description))
            {
                throw new ArgumentException("Description is required.", nameof(eventDto.Description));
            }

            if (string.IsNullOrWhiteSpace(eventDto.Status))
            {
                throw new ArgumentException("Status is required.", nameof(eventDto.Status));
            }

            if (eventDto.DateOfEvent < DateOnly.FromDateTime(DateTime.Today))
            {
                throw new ArgumentException("Event date cannot be in the past.", nameof(eventDto.DateOfEvent));
            }

            if (eventDto.StartTime >= eventDto.EndTime)
            {
                throw new ArgumentException("StartTime must be before EndTime.", nameof(eventDto.StartTime));
            }

            if (eventDto.TrashCollected.HasValue && eventDto.TrashCollected < 0)
            {
                throw new ArgumentException("TrashCollected cannot be negative.", nameof(eventDto.TrashCollected));
            }

            if (eventDto.NumberOfAttendees < 0)
            {
                throw new ArgumentException("NumberOfAttendees cannot be negative.", nameof(eventDto.NumberOfAttendees));
            }
        }
    }
}
